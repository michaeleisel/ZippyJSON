///
///  BinaryEncodingKeyedContainerTests.swift
///
///  Copyright 2017 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 10/6/17.
///
import XCTest

///
/// Note: This file contains public interface tests so do not use @testable.
///
import ZippyJSON

/// =================================== NOTICE ========================================
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
/// Modify the  *.swift.gyb file instead.
/// ===================================================================================

///
/// `BinaryEncodingKeyedStructuredTypeTests`
///
class BinaryEncodingKeyedContainerTests: XCTestCase {

    // MARK: - `Bool` Tests

    ///
    /// Test the ability to encode/decode a class with a `Bool` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassBoolKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: true)) { (result) in
            XCTAssertEqual(result.value, true)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Bool` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalBoolKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Bool?
            init(value: Bool?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: true)) { (result) in
            XCTAssertEqual(result.value, true)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Bool` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalBoolWithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Bool?
            init(value: Bool?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Bool` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructBoolKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: true)) { (result) in
            XCTAssertEqual(result.value, true)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Bool` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalBoolKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Bool?
            init(value: Bool?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: true)) { (result) in
            XCTAssertEqual(result.value, true)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Bool` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalBoolWithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Bool?
            init(value: Bool?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Int` Tests

    ///
    /// Test the ability to encode/decode a class with a `Int` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassIntKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int
            init(value: Int) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalIntKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int?
            init(value: Int?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalIntWithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int?
            init(value: Int?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Int` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructIntKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int
            init(value: Int) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalIntKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int?
            init(value: Int?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalIntWithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int?
            init(value: Int?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Int8` Tests

    ///
    /// Test the ability to encode/decode a class with a `Int8` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassInt8Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int8
            init(value: Int8) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int8` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt8Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int8?
            init(value: Int8?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int8` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt8WithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int8?
            init(value: Int8?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Int8` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructInt8Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int8
            init(value: Int8) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int8` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt8Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int8?
            init(value: Int8?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int8` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt8WithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int8?
            init(value: Int8?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Int16` Tests

    ///
    /// Test the ability to encode/decode a class with a `Int16` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassInt16Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int16
            init(value: Int16) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int16` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt16Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int16?
            init(value: Int16?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int16` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt16WithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int16?
            init(value: Int16?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Int16` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructInt16Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int16
            init(value: Int16) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int16` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt16Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int16?
            init(value: Int16?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int16` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt16WithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int16?
            init(value: Int16?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Int32` Tests

    ///
    /// Test the ability to encode/decode a class with a `Int32` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassInt32Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int32
            init(value: Int32) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int32` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt32Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int32?
            init(value: Int32?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int32` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt32WithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int32?
            init(value: Int32?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Int32` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructInt32Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int32
            init(value: Int32) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int32` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt32Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int32?
            init(value: Int32?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int32` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt32WithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int32?
            init(value: Int32?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Int64` Tests

    ///
    /// Test the ability to encode/decode a class with a `Int64` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassInt64Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int64
            init(value: Int64) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int64` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt64Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int64?
            init(value: Int64?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int64` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt64WithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int64?
            init(value: Int64?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Int64` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructInt64Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int64
            init(value: Int64) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int64` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt64Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int64?
            init(value: Int64?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int64` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt64WithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Int64?
            init(value: Int64?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `UInt` Tests

    ///
    /// Test the ability to encode/decode a class with a `UInt` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassUIntKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt
            init(value: UInt) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUIntKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt?
            init(value: UInt?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUIntWithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt?
            init(value: UInt?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `UInt` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructUIntKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt
            init(value: UInt) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUIntKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt?
            init(value: UInt?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUIntWithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt?
            init(value: UInt?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `UInt8` Tests

    ///
    /// Test the ability to encode/decode a class with a `UInt8` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassUInt8Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt8
            init(value: UInt8) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt8` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt8Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt8?
            init(value: UInt8?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt8` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt8WithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt8?
            init(value: UInt8?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `UInt8` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructUInt8Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt8
            init(value: UInt8) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt8` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt8Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt8?
            init(value: UInt8?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt8` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt8WithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt8?
            init(value: UInt8?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `UInt16` Tests

    ///
    /// Test the ability to encode/decode a class with a `UInt16` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassUInt16Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt16
            init(value: UInt16) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt16` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt16Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt16?
            init(value: UInt16?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt16` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt16WithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt16?
            init(value: UInt16?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `UInt16` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructUInt16Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt16
            init(value: UInt16) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt16` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt16Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt16?
            init(value: UInt16?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt16` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt16WithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt16?
            init(value: UInt16?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `UInt32` Tests

    ///
    /// Test the ability to encode/decode a class with a `UInt32` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassUInt32Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt32
            init(value: UInt32) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt32` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt32Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt32?
            init(value: UInt32?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt32` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt32WithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt32?
            init(value: UInt32?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `UInt32` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructUInt32Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt32
            init(value: UInt32) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt32` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt32Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt32?
            init(value: UInt32?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt32` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt32WithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt32?
            init(value: UInt32?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `UInt64` Tests

    ///
    /// Test the ability to encode/decode a class with a `UInt64` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassUInt64Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt64
            init(value: UInt64) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt64` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt64Keyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt64?
            init(value: UInt64?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt64` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt64WithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt64?
            init(value: UInt64?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `UInt64` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructUInt64Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt64
            init(value: UInt64) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt64` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt64Keyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt64?
            init(value: UInt64?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt64` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt64WithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: UInt64?
            init(value: UInt64?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Float` Tests

    ///
    /// Test the ability to encode/decode a class with a `Float` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassFloatKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Float
            init(value: Float) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Float` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalFloatKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Float?
            init(value: Float?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Float` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalFloatWithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Float?
            init(value: Float?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Float` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructFloatKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Float
            init(value: Float) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Float` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalFloatKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Float?
            init(value: Float?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Float` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalFloatWithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Float?
            init(value: Float?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Double` Tests

    ///
    /// Test the ability to encode/decode a class with a `Double` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassDoubleKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Double
            init(value: Double) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Double` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalDoubleKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Double?
            init(value: Double?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Double` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalDoubleWithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Double?
            init(value: Double?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Double` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructDoubleKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Double
            init(value: Double) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Double` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalDoubleKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Double?
            init(value: Double?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Double` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalDoubleWithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: Double?
            init(value: Double?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `String` Tests

    ///
    /// Test the ability to encode/decode a class with a `String` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassStringKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: String
            init(value: String) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: "Test String")) { (result) in
            XCTAssertEqual(result.value, "Test String")
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `String` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalStringKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: String?
            init(value: String?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: "Test String")) { (result) in
            XCTAssertEqual(result.value, "Test String")
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `String` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalStringWithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: String?
            init(value: String?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `String` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructStringKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: String
            init(value: String) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: "Test String")) { (result) in
            XCTAssertEqual(result.value, "Test String")
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `String` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalStringKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: String?
            init(value: String?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: "Test String")) { (result) in
            XCTAssertEqual(result.value, "Test String")
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `String` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalStringWithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: String?
            init(value: String?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `CodableType` Tests

    ///
    /// Test the ability to encode/decode a class with a `CodableType` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassCodableTypeKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: CodableType
            init(value: CodableType) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: CodableType(32))) { (result) in
            XCTAssertEqual(result.value, CodableType(32))
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `CodableType` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalCodableTypeKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: CodableType?
            init(value: CodableType?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: CodableType(32))) { (result) in
            XCTAssertEqual(result.value, CodableType(32))
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `CodableType` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalCodableTypeWithNilKeyed() {

        class InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: CodableType?
            init(value: CodableType?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `CodableType` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructCodableTypeKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: CodableType
            init(value: CodableType) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: CodableType(32))) { (result) in
            XCTAssertEqual(result.value, CodableType(32))
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `CodableType` value using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalCodableTypeKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: CodableType?
            init(value: CodableType?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: CodableType(32))) { (result) in
            XCTAssertEqual(result.value, CodableType(32))
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `CodableType` value when the value is nul using a KeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalCodableTypeWithNilKeyed() {

        struct InputType: Codable { /// Note: we use the default `Codable` implementation for Keyed types.
            var value: CodableType?
            init(value: CodableType?) { self.value = value }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encodeNil/decodeNil using a KeyedContainer
    ///
    func testEncodeDecodeNilWithKeyedContainer() {

        struct InputType: Codable {
            var value: String?
            init(value: String?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)

                if !(try container.decodeNil(forKey: .value)) {
                    self.value = try container.decode(String.self, forKey: .value)
                }
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)

                if let value = self.value {
                    try container.encode(value, forKey: .value)
                } else {
                    try container.encodeNil(forKey: .value)
                }
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a value using a nested KeyedContainer from a KeyedContainer.
    ///
    func testEncodeDecodeWithKeyedAndNestedKeyedContainers() {

        struct InputType: Codable {
            var first: String
            var last:  String
            init(first: String, last: String) { self.first = first; self.last = last }

            enum CodingKeys: CodingKey { case name }
            enum NestedKeys: CodingKey { case first, last }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                let nestedContainer = try container.nestedContainer(keyedBy: NestedKeys.self, forKey: .name)

                self.first = try nestedContainer.decode(String.self, forKey: .first)
                self.last  = try nestedContainer.decode(String.self, forKey: .last)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                var nestedContainer = container.nestedContainer(keyedBy: NestedKeys.self, forKey: .name)

                try nestedContainer.encode(self.first, forKey: .first)
                try nestedContainer.encode(self.last,  forKey: .last)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(first: "First", last: "Last")) { (result) in
            XCTAssertEqual(result.first, "First")
            XCTAssertEqual(result.last,  "Last")
        }
    }

    ///
    /// Test the ability to encode/decode a value using a nested UnkeyedContainer from a KeyedContainer.
    ///
    func testEncodeWithKeyedAndNestedUnkeyedContainers() {

        struct InputType: Codable {
            var first: String
            var last:  String
            init(first: String, last: String) { self.first = first; self.last = last }

            enum CodingKeys: CodingKey { case name }
            enum NestedKeys: CodingKey { case first, last }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                var nestedContainer = try container.nestedUnkeyedContainer(forKey: .name)

                self.first = try nestedContainer.decode(String.self)
                self.last  = try nestedContainer.decode(String.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                var nestedContainer = container.nestedUnkeyedContainer(forKey: .name)

                try nestedContainer.encode(self.first)
                try nestedContainer.encode(self.last)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(first: "First", last: "Last")) { (result) in
            XCTAssertEqual(result.first, "First")
            XCTAssertEqual(result.last,  "Last")
        }
    }

    ///
    /// Test the ability to encode/decode a value calling keyedContainer  multiple times.
    ///
    func testEncodeCallingMultipleKeyedContainers() {

        struct InputType: Codable {
            var value: String
            init(value: String) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                let _ = try decoder.container(keyedBy: CodingKeys.self)

                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.value = try container.decode(String.self, forKey: .value)
            }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.container(keyedBy: CodingKeys.self) /// throw the first away
                let _ = encoder.container(keyedBy: CodingKeys.self) /// And the second

                /// Use the third
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encode(self.value, forKey: .value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: "Test Value")) { (result) in
            XCTAssertEqual(result.value, "Test Value")
        }
    }

    ///
    /// Test the ability to encode/decode using a KeyedContainer's keyed superEncoder/superDecoder for the super class.
    ///
    func testEncodeDecodeWithSuperEncoderDecoderKeyedContainer() {

        class SuperType: Codable {
            let superValue: Int
            init(superValue: Int) { self.superValue = superValue }

            private enum CodingKeys: CodingKey { case superValue }

            required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self); self.superValue = try container.decode(Int.self, forKey: .superValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self); try container.encode(self.superValue, forKey: .superValue)
            }
        }

        class SubType: SuperType {
            let subValue: String
            init(subValue: String, superValue: Int) {
                self.subValue = subValue; super.init(superValue: superValue)
            }

            private enum CodingKeys: CodingKey { case subValue, superClass }

            required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self); self.subValue = try container.decode(String.self, forKey: .subValue)

                try super.init(from: try container.superDecoder(forKey: .superClass))
            }
            override func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self); try container.encode(subValue, forKey: .subValue)

                try super.encode(to: container.superEncoder(forKey: .superClass))
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: SubType(subValue: "Test Value", superValue: 32)) { (result) in
            XCTAssertEqual(result.subValue, "Test Value")
            XCTAssertEqual(result.superValue, 32)
        }
    }

    ///
    /// Test the ability to encode/decode using a KeyedContainer's unkeyed superEncoder/superDecoder for the super class.
    ///
    func testEncodeDecodeWithSuperEncoderDecoderUnkeyedContainer() {

        class SuperType: Codable {
            let superValue: Int
            init(superValue: Int) { self.superValue = superValue }

            private enum CodingKeys: CodingKey { case superValue }

            required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self); self.superValue = try container.decode(Int.self, forKey: .superValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self); try container.encode(self.superValue, forKey: .superValue)
            }
        }

        class SubType: SuperType {
            let subValue: String
            init(subValue: String, superValue: Int) {
                self.subValue = subValue; super.init(superValue: superValue)
            }

            private enum CodingKeys: CodingKey { case subValue, superClass }

            required init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self); self.subValue = try container.decode(String.self, forKey: .subValue)

                try super.init(from: try container.superDecoder())
            }
            override func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self); try container.encode(subValue, forKey: .subValue)

                try super.encode(to: container.superEncoder())
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: SubType(subValue: "Test Value", superValue: 32)) { (result) in
            XCTAssertEqual(result.subValue, "Test Value")
            XCTAssertEqual(result.superValue, 32)
        }
    }
}

