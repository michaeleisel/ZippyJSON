///
///  BinaryEncodingKeyedContainerNegativeTests.swift
///
///  Copyright 2017 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 10/23/17.
///
import XCTest

///
/// Note: This file contains public interface tests so do not use @testable.
///
import ZippyJSON


/// =================================== NOTICE ========================================
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
/// Modify the  *.swift.gyb file instead.
/// ===================================================================================

///
/// Negative tests for keyed containers.
///
class BinaryEncodingKeyedContainerNegativeTests: XCTestCase {

    ///
    /// `decodeNil()` should throw the following error based on the `KeyedDecodingContainerProtocol` protocol.
    ///
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry for the given key.
    ///
    /// And throws the following implementation specific errors:
    ///
    /// - throws: `DecodingError.typeMismatch` if the encountered `StorageContainer` is not convertible to a `SingleValueContainer`.
    ///

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decodeNil for a key not contained in the encoded data.
    ///
    func testDecodeNilWhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decodeNil(forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// All `decode()` methods should throw the following errors:
    ///
    /// - throws: `DecodingError.typeMismatch` if the encountered encoded value is not convertible to the requested type.
    /// - throws: `DecodingError.keyNotFound` if `self` does not have an entry for the given key.
    /// - throws: `DecodingError.valueNotFound` if `self` has a null entry for the given key.
    ///
    /// And throws the following implementation specific errors:
    ///
    /// - throws: `DecodingError.typeMismatch` if the encountered `StorageContainer` is not convertible to a `SingleValueContainer`.
    ///

    // MARK: - `Bool` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeBoolWhenKeyNotFound() {

        struct InputType: Codable {
            var value: Int
            init(value: Int) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(Bool.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: 64), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Bool` value that was encoded as an `Int` type when using a KeyedContainer.
    ///
    func testDecodeBoolWhenTypeMismatch() {

        struct InputType: Codable {
            var value: Int
            init(value: Int) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 64), expected: (ExpectedType.self, Bool.self, [ExpectedType.CodingKeys.value], "Expected to decode Bool but found Int instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Bool` value that is nil.
    ///
    func testDecodeBoolWhenValueNotFound() {

        struct InputType: Codable {
            var value: Bool?
            init(value: Bool?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Bool.self, [ExpectedType.CodingKeys.value], "Expected Bool value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Bool` value and finds a different container type.
    ///
    func testDecodeBoolWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Int` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeIntWhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Int
            init(value: Int) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(Int.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeIntWhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Int
            init(value: Int) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int.self, [ExpectedType.CodingKeys.value], "Expected to decode Int but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int` value that is nil.
    ///
    func testDecodeIntWhenValueNotFound() {

        struct InputType: Codable {
            var value: Int?
            init(value: Int?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int
            init(value: Int) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int.self, [ExpectedType.CodingKeys.value], "Expected Int value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int` value and finds a different container type.
    ///
    func testDecodeIntWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int
            init(value: Int) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int
            init(value: Int) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Int8` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeInt8WhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Int8
            init(value: Int8) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(Int8.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int8` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeInt8WhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Int8
            init(value: Int8) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int8.self, [ExpectedType.CodingKeys.value], "Expected to decode Int8 but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int8` value that is nil.
    ///
    func testDecodeInt8WhenValueNotFound() {

        struct InputType: Codable {
            var value: Int8?
            init(value: Int8?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int8
            init(value: Int8) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int8.self, [ExpectedType.CodingKeys.value], "Expected Int8 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int8` value and finds a different container type.
    ///
    func testDecodeInt8WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int8
            init(value: Int8) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int8.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int8
            init(value: Int8) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Int16` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeInt16WhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(Int16.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int16` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeInt16WhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int16.self, [ExpectedType.CodingKeys.value], "Expected to decode Int16 but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int16` value that is nil.
    ///
    func testDecodeInt16WhenValueNotFound() {

        struct InputType: Codable {
            var value: Int16?
            init(value: Int16?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int16.self, [ExpectedType.CodingKeys.value], "Expected Int16 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int16` value and finds a different container type.
    ///
    func testDecodeInt16WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int16.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Int32` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeInt32WhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(Int32.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int32` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeInt32WhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int32.self, [ExpectedType.CodingKeys.value], "Expected to decode Int32 but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int32` value that is nil.
    ///
    func testDecodeInt32WhenValueNotFound() {

        struct InputType: Codable {
            var value: Int32?
            init(value: Int32?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int32.self, [ExpectedType.CodingKeys.value], "Expected Int32 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int32` value and finds a different container type.
    ///
    func testDecodeInt32WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int32.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Int64` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeInt64WhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(Int64.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int64` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeInt64WhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int64.self, [ExpectedType.CodingKeys.value], "Expected to decode Int64 but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int64` value that is nil.
    ///
    func testDecodeInt64WhenValueNotFound() {

        struct InputType: Codable {
            var value: Int64?
            init(value: Int64?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int64.self, [ExpectedType.CodingKeys.value], "Expected Int64 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int64` value and finds a different container type.
    ///
    func testDecodeInt64WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int64.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `UInt` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeUIntWhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(UInt.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeUIntWhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt.self, [ExpectedType.CodingKeys.value], "Expected to decode UInt but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt` value that is nil.
    ///
    func testDecodeUIntWhenValueNotFound() {

        struct InputType: Codable {
            var value: UInt?
            init(value: UInt?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt.self, [ExpectedType.CodingKeys.value], "Expected UInt value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt` value and finds a different container type.
    ///
    func testDecodeUIntWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `UInt8` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeUInt8WhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(UInt8.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt8` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeUInt8WhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt8.self, [ExpectedType.CodingKeys.value], "Expected to decode UInt8 but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt8` value that is nil.
    ///
    func testDecodeUInt8WhenValueNotFound() {

        struct InputType: Codable {
            var value: UInt8?
            init(value: UInt8?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt8.self, [ExpectedType.CodingKeys.value], "Expected UInt8 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt8` value and finds a different container type.
    ///
    func testDecodeUInt8WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt8.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `UInt16` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeUInt16WhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(UInt16.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt16` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeUInt16WhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt16.self, [ExpectedType.CodingKeys.value], "Expected to decode UInt16 but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt16` value that is nil.
    ///
    func testDecodeUInt16WhenValueNotFound() {

        struct InputType: Codable {
            var value: UInt16?
            init(value: UInt16?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt16.self, [ExpectedType.CodingKeys.value], "Expected UInt16 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt16` value and finds a different container type.
    ///
    func testDecodeUInt16WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt16.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `UInt32` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeUInt32WhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(UInt32.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt32` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeUInt32WhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt32.self, [ExpectedType.CodingKeys.value], "Expected to decode UInt32 but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt32` value that is nil.
    ///
    func testDecodeUInt32WhenValueNotFound() {

        struct InputType: Codable {
            var value: UInt32?
            init(value: UInt32?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt32.self, [ExpectedType.CodingKeys.value], "Expected UInt32 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt32` value and finds a different container type.
    ///
    func testDecodeUInt32WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt32.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `UInt64` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeUInt64WhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(UInt64.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt64` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeUInt64WhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt64.self, [ExpectedType.CodingKeys.value], "Expected to decode UInt64 but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt64` value that is nil.
    ///
    func testDecodeUInt64WhenValueNotFound() {

        struct InputType: Codable {
            var value: UInt64?
            init(value: UInt64?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt64.self, [ExpectedType.CodingKeys.value], "Expected UInt64 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt64` value and finds a different container type.
    ///
    func testDecodeUInt64WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt64.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Float` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeFloatWhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Float
            init(value: Float) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(Float.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Float` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeFloatWhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Float
            init(value: Float) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Float.self, [ExpectedType.CodingKeys.value], "Expected to decode Float but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Float` value that is nil.
    ///
    func testDecodeFloatWhenValueNotFound() {

        struct InputType: Codable {
            var value: Float?
            init(value: Float?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: Float
            init(value: Float) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Float.self, [ExpectedType.CodingKeys.value], "Expected Float value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Float` value and finds a different container type.
    ///
    func testDecodeFloatWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Float
            init(value: Float) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Float.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Float
            init(value: Float) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Double` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeDoubleWhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Double
            init(value: Double) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(Double.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Double` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeDoubleWhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: Double
            init(value: Double) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Double.self, [ExpectedType.CodingKeys.value], "Expected to decode Double but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Double` value that is nil.
    ///
    func testDecodeDoubleWhenValueNotFound() {

        struct InputType: Codable {
            var value: Double?
            init(value: Double?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: Double
            init(value: Double) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Double.self, [ExpectedType.CodingKeys.value], "Expected Double value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Double` value and finds a different container type.
    ///
    func testDecodeDoubleWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Double
            init(value: Double) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Double.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Double
            init(value: Double) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `String` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeStringWhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: String
            init(value: String) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(String.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `String` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeStringWhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: String
            init(value: String) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, String.self, [ExpectedType.CodingKeys.value], "Expected to decode String but found Bool instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `String` value that is nil.
    ///
    func testDecodeStringWhenValueNotFound() {

        struct InputType: Codable {
            var value: String?
            init(value: String?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: String
            init(value: String) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, String.self, [ExpectedType.CodingKeys.value], "Expected String value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `String` value and finds a different container type.
    ///
    func testDecodeStringWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: String
            init(value: String) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(String.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: String
            init(value: String) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: "Test String"), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `CodableType` Tests

    ///
    /// Test that a `DecodingError.keyNotFound` is thrown when a user tries to decode a value for a key not contained in the encoded data.
    ///
    func testDecodeCodableTypeWhenKeyNotFound() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }
            enum AlternateCodingKeys: CodingKey {
                case invalidValue
                var description: String {
                    return "\(self.stringValue)"
                }
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: AlternateCodingKeys.self)

                self.value = try container.decode(CodableType.self, forKey: .invalidValue)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: AlternateCodingKeys.self)

                try container.encode(self.value, forKey: .invalidValue)
            }
        }
        _testDecodeKeyNotFound(input: InputType(value: true), expected: (ExpectedType.self, ExpectedType.AlternateCodingKeys.invalidValue, [ExpectedType.AlternateCodingKeys.invalidValue], "No value associated with key \"invalidValue\"."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `CodableType` value that was encoded as an `Bool` type when using a KeyedContainer.
    ///
    func testDecodeCodableTypeWhenTypeMismatch() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }

        struct ExpectedType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, KeyedDecodingContainer<CodableType.CodingKeys>.self, [ExpectedType.CodingKeys.value], "Expected to decode KeyedDecodingContainer<CodingKeys> but found SingleValueDecodingContainer instead."))
   }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `CodableType` value that is nil.
    ///
    func testDecodeCodableTypeWhenValueNotFound() {

        struct InputType: Codable {
            var value: CodableType?
            init(value: CodableType?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                self.value = nil
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeNil(forKey: .value)
            }
        }

        struct ExpectedType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, CodableType.self, [ExpectedType.CodingKeys.value], "Expected CodableType value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `CodableType` value and finds a different container type.
    ///
    func testDecodeCodableTypeWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(CodableType.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }
            enum CodingKeys: CodingKey { case value }
        }
        _testDecodeTypeMismatch(input: InputType(value: CodableType(32)), expected: (ExpectedType.self, KeyedDecodingContainer<ExpectedType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }
}

