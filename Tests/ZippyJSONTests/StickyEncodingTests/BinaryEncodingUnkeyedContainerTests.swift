///
///  BinaryEncodingUnkeyedContainerTests.swift
///
///  Copyright 2017 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 10/6/17.
///
import XCTest

///
/// Note: This file contains public interface tests so do not use @testable.
///
import ZippyJSON

/// =================================== NOTICE ========================================
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
/// Modify the  *.swift.gyb file instead.
/// ===================================================================================

///
/// Tests relating to both `BinaryEncoder` and `BinaryDecoder` for unkeyed containers when encoding structured types (custom class and structs).
///
class BinaryEncodingUnkeyedContainerTests: XCTestCase {

    // MARK: - `Bool` Tests


    ///
    /// Test the ability to encode/decode a class with a `Bool` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassBoolUnkeyed() {

        class InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: true)) { (result) in
            XCTAssertEqual(result.value, true)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Bool` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalBoolUnkeyed() {

        class InputType: Codable {
            var value: Bool?
            init(value: Bool?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Bool.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: true)) { (result) in
            XCTAssertEqual(result.value, true)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Bool` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalBoolWithNilUnkeyed() {

        class InputType: Codable {
            var value: Bool?
            init(value: Bool?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Bool.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Bool` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructBoolUnkeyed() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: true)) { (result) in
            XCTAssertEqual(result.value, true)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Bool` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalBoolUnkeyed() {

        struct InputType: Codable {
            var value: Bool?
            init(value: Bool?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Bool.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: true)) { (result) in
            XCTAssertEqual(result.value, true)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Bool` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalBoolWithNilUnkeyed() {

        struct InputType: Codable {
            var value: Bool?
            init(value: Bool?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Bool.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Int` Tests


    ///
    /// Test the ability to encode/decode a class with a `Int` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassIntUnkeyed() {

        class InputType: Codable {
            var value: Int
            init(value: Int) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalIntUnkeyed() {

        class InputType: Codable {
            var value: Int?
            init(value: Int?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalIntWithNilUnkeyed() {

        class InputType: Codable {
            var value: Int?
            init(value: Int?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Int` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructIntUnkeyed() {

        struct InputType: Codable {
            var value: Int
            init(value: Int) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalIntUnkeyed() {

        struct InputType: Codable {
            var value: Int?
            init(value: Int?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalIntWithNilUnkeyed() {

        struct InputType: Codable {
            var value: Int?
            init(value: Int?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Int8` Tests


    ///
    /// Test the ability to encode/decode a class with a `Int8` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassInt8Unkeyed() {

        class InputType: Codable {
            var value: Int8
            init(value: Int8) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int8.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int8` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt8Unkeyed() {

        class InputType: Codable {
            var value: Int8?
            init(value: Int8?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int8.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int8` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt8WithNilUnkeyed() {

        class InputType: Codable {
            var value: Int8?
            init(value: Int8?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int8.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Int8` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructInt8Unkeyed() {

        struct InputType: Codable {
            var value: Int8
            init(value: Int8) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int8.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int8` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt8Unkeyed() {

        struct InputType: Codable {
            var value: Int8?
            init(value: Int8?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int8.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int8` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt8WithNilUnkeyed() {

        struct InputType: Codable {
            var value: Int8?
            init(value: Int8?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int8.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Int16` Tests


    ///
    /// Test the ability to encode/decode a class with a `Int16` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassInt16Unkeyed() {

        class InputType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int16.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int16` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt16Unkeyed() {

        class InputType: Codable {
            var value: Int16?
            init(value: Int16?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int16.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int16` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt16WithNilUnkeyed() {

        class InputType: Codable {
            var value: Int16?
            init(value: Int16?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int16.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Int16` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructInt16Unkeyed() {

        struct InputType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int16.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int16` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt16Unkeyed() {

        struct InputType: Codable {
            var value: Int16?
            init(value: Int16?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int16.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int16` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt16WithNilUnkeyed() {

        struct InputType: Codable {
            var value: Int16?
            init(value: Int16?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int16.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Int32` Tests


    ///
    /// Test the ability to encode/decode a class with a `Int32` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassInt32Unkeyed() {

        class InputType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int32.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int32` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt32Unkeyed() {

        class InputType: Codable {
            var value: Int32?
            init(value: Int32?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int32.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int32` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt32WithNilUnkeyed() {

        class InputType: Codable {
            var value: Int32?
            init(value: Int32?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int32.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Int32` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructInt32Unkeyed() {

        struct InputType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int32.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int32` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt32Unkeyed() {

        struct InputType: Codable {
            var value: Int32?
            init(value: Int32?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int32.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int32` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt32WithNilUnkeyed() {

        struct InputType: Codable {
            var value: Int32?
            init(value: Int32?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int32.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Int64` Tests


    ///
    /// Test the ability to encode/decode a class with a `Int64` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassInt64Unkeyed() {

        class InputType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int64.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int64` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt64Unkeyed() {

        class InputType: Codable {
            var value: Int64?
            init(value: Int64?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int64.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Int64` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalInt64WithNilUnkeyed() {

        class InputType: Codable {
            var value: Int64?
            init(value: Int64?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int64.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Int64` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructInt64Unkeyed() {

        struct InputType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int64.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int64` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt64Unkeyed() {

        struct InputType: Codable {
            var value: Int64?
            init(value: Int64?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int64.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Int64` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalInt64WithNilUnkeyed() {

        struct InputType: Codable {
            var value: Int64?
            init(value: Int64?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Int64.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `UInt` Tests


    ///
    /// Test the ability to encode/decode a class with a `UInt` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassUIntUnkeyed() {

        class InputType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUIntUnkeyed() {

        class InputType: Codable {
            var value: UInt?
            init(value: UInt?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUIntWithNilUnkeyed() {

        class InputType: Codable {
            var value: UInt?
            init(value: UInt?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `UInt` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructUIntUnkeyed() {

        struct InputType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUIntUnkeyed() {

        struct InputType: Codable {
            var value: UInt?
            init(value: UInt?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUIntWithNilUnkeyed() {

        struct InputType: Codable {
            var value: UInt?
            init(value: UInt?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `UInt8` Tests


    ///
    /// Test the ability to encode/decode a class with a `UInt8` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassUInt8Unkeyed() {

        class InputType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt8.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt8` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt8Unkeyed() {

        class InputType: Codable {
            var value: UInt8?
            init(value: UInt8?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt8.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt8` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt8WithNilUnkeyed() {

        class InputType: Codable {
            var value: UInt8?
            init(value: UInt8?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt8.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `UInt8` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructUInt8Unkeyed() {

        struct InputType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt8.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt8` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt8Unkeyed() {

        struct InputType: Codable {
            var value: UInt8?
            init(value: UInt8?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt8.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt8` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt8WithNilUnkeyed() {

        struct InputType: Codable {
            var value: UInt8?
            init(value: UInt8?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt8.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `UInt16` Tests


    ///
    /// Test the ability to encode/decode a class with a `UInt16` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassUInt16Unkeyed() {

        class InputType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt16.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt16` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt16Unkeyed() {

        class InputType: Codable {
            var value: UInt16?
            init(value: UInt16?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt16.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt16` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt16WithNilUnkeyed() {

        class InputType: Codable {
            var value: UInt16?
            init(value: UInt16?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt16.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `UInt16` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructUInt16Unkeyed() {

        struct InputType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt16.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt16` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt16Unkeyed() {

        struct InputType: Codable {
            var value: UInt16?
            init(value: UInt16?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt16.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt16` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt16WithNilUnkeyed() {

        struct InputType: Codable {
            var value: UInt16?
            init(value: UInt16?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt16.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `UInt32` Tests


    ///
    /// Test the ability to encode/decode a class with a `UInt32` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassUInt32Unkeyed() {

        class InputType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt32.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt32` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt32Unkeyed() {

        class InputType: Codable {
            var value: UInt32?
            init(value: UInt32?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt32.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt32` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt32WithNilUnkeyed() {

        class InputType: Codable {
            var value: UInt32?
            init(value: UInt32?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt32.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `UInt32` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructUInt32Unkeyed() {

        struct InputType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt32.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt32` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt32Unkeyed() {

        struct InputType: Codable {
            var value: UInt32?
            init(value: UInt32?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt32.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt32` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt32WithNilUnkeyed() {

        struct InputType: Codable {
            var value: UInt32?
            init(value: UInt32?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt32.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `UInt64` Tests


    ///
    /// Test the ability to encode/decode a class with a `UInt64` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassUInt64Unkeyed() {

        class InputType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt64.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt64` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt64Unkeyed() {

        class InputType: Codable {
            var value: UInt64?
            init(value: UInt64?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt64.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `UInt64` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalUInt64WithNilUnkeyed() {

        class InputType: Codable {
            var value: UInt64?
            init(value: UInt64?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt64.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `UInt64` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructUInt64Unkeyed() {

        struct InputType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt64.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt64` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt64Unkeyed() {

        struct InputType: Codable {
            var value: UInt64?
            init(value: UInt64?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt64.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32)) { (result) in
            XCTAssertEqual(result.value, 32)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `UInt64` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalUInt64WithNilUnkeyed() {

        struct InputType: Codable {
            var value: UInt64?
            init(value: UInt64?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(UInt64.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Float` Tests


    ///
    /// Test the ability to encode/decode a class with a `Float` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassFloatUnkeyed() {

        class InputType: Codable {
            var value: Float
            init(value: Float) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Float.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Float` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalFloatUnkeyed() {

        class InputType: Codable {
            var value: Float?
            init(value: Float?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Float.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Float` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalFloatWithNilUnkeyed() {

        class InputType: Codable {
            var value: Float?
            init(value: Float?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Float.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Float` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructFloatUnkeyed() {

        struct InputType: Codable {
            var value: Float
            init(value: Float) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Float.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Float` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalFloatUnkeyed() {

        struct InputType: Codable {
            var value: Float?
            init(value: Float?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Float.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Float` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalFloatWithNilUnkeyed() {

        struct InputType: Codable {
            var value: Float?
            init(value: Float?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Float.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `Double` Tests


    ///
    /// Test the ability to encode/decode a class with a `Double` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassDoubleUnkeyed() {

        class InputType: Codable {
            var value: Double
            init(value: Double) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Double.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Double` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalDoubleUnkeyed() {

        class InputType: Codable {
            var value: Double?
            init(value: Double?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Double.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `Double` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalDoubleWithNilUnkeyed() {

        class InputType: Codable {
            var value: Double?
            init(value: Double?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Double.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `Double` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructDoubleUnkeyed() {

        struct InputType: Codable {
            var value: Double
            init(value: Double) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Double.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Double` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalDoubleUnkeyed() {

        struct InputType: Codable {
            var value: Double?
            init(value: Double?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Double.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: 32.0)) { (result) in
            XCTAssertEqual(result.value, 32.0)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `Double` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalDoubleWithNilUnkeyed() {

        struct InputType: Codable {
            var value: Double?
            init(value: Double?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(Double.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `String` Tests


    ///
    /// Test the ability to encode/decode a class with a `String` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassStringUnkeyed() {

        class InputType: Codable {
            var value: String
            init(value: String) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(String.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: "Test String")) { (result) in
            XCTAssertEqual(result.value, "Test String")
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `String` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalStringUnkeyed() {

        class InputType: Codable {
            var value: String?
            init(value: String?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(String.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: "Test String")) { (result) in
            XCTAssertEqual(result.value, "Test String")
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `String` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalStringWithNilUnkeyed() {

        class InputType: Codable {
            var value: String?
            init(value: String?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(String.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `String` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructStringUnkeyed() {

        struct InputType: Codable {
            var value: String
            init(value: String) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(String.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: "Test String")) { (result) in
            XCTAssertEqual(result.value, "Test String")
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `String` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalStringUnkeyed() {

        struct InputType: Codable {
            var value: String?
            init(value: String?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(String.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: "Test String")) { (result) in
            XCTAssertEqual(result.value, "Test String")
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `String` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalStringWithNilUnkeyed() {

        struct InputType: Codable {
            var value: String?
            init(value: String?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(String.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    // MARK: - `CodableType` Tests


    ///
    /// Test the ability to encode/decode a class with a `CodableType` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassCodableTypeUnkeyed() {

        class InputType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(CodableType.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: CodableType(32))) { (result) in
            XCTAssertEqual(result.value, CodableType(32))
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `CodableType` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalCodableTypeUnkeyed() {

        class InputType: Codable {
            var value: CodableType?
            init(value: CodableType?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(CodableType.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: CodableType(32))) { (result) in
            XCTAssertEqual(result.value, CodableType(32))
        }
    }

    ///
    /// Test the ability to encode/decode a class with an optional `CodableType` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfClassOptionalCodableTypeWithNilUnkeyed() {

        class InputType: Codable {
            var value: CodableType?
            init(value: CodableType?) { self.value = value }

            required
            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(CodableType.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a struct with a `CodableType` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructCodableTypeUnkeyed() {

        struct InputType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(CodableType.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: CodableType(32))) { (result) in
            XCTAssertEqual(result.value, CodableType(32))
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `CodableType` value using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalCodableTypeUnkeyed() {

        struct InputType: Codable {
            var value: CodableType?
            init(value: CodableType?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(CodableType.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: CodableType(32))) { (result) in
            XCTAssertEqual(result.value, CodableType(32))
        }
    }

    ///
    /// Test the ability to encode/decode a struct with an optional `CodableType` value when the value is nul using a UnkeyedContainer.
    ///
    func testEncodeDecodeOfStructOptionalCodableTypeWithNilUnkeyed() {

        struct InputType: Codable {
            var value: CodableType?
            init(value: CodableType?) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decodeIfPresent(CodableType.self)
            }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encodeNil/decodeNil using a UnkeyedContainer.
    ///
    func testEncodeNilWithUnkeyedContainer() {

        struct InputType: Codable {
            var value: String?
            init(value: String?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()

                if !(try container.decodeNil()) {
                    self.value = try container.decode(String.self)
                }
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()

                if let value = self.value {
                    try container.encode(value)
                } else {
                    try container.encodeNil()
                }
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: nil)) { (result) in
            XCTAssertEqual(result.value, nil)
        }
    }

    ///
    /// Test the ability to encode/decode a value using a nested KeyedContainer from a UnkeyedContainer.
    ///
    func testEncodeDecodeWithUnkeyedAndNestedUnkeyedContainer() {

        struct InputType: Codable {
            var first: String
            var last:  String
            init(first: String, last: String) { self.first = first; self.last = last }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                var nestedContainer = try container.nestedUnkeyedContainer()

                self.first = try nestedContainer.decode(String.self)
                self.last  = try nestedContainer.decode(String.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()

                try nestedContainer.encode(self.first)
                try nestedContainer.encode(self.last)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(first: "First", last: "Last")) { (result) in
            XCTAssertEqual(result.first, "First")
            XCTAssertEqual(result.last,  "Last")
        }
    }

    ///
    /// Test the ability to encode/decode a value using a nested UnkeyedContainer from a UnkeyedContainer.
    ///
    func testEncodeDecodeWithUnkeyedAndNestedKeyedContainers() {

        struct InputType: Codable {
            var first: String
            var last:  String
            init(first: String, last: String) { self.first = first; self.last = last }

            enum CodingKeys: CodingKey { case name }
            enum NestedKeys: CodingKey { case first, last }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                let nestedContainer = try container.nestedContainer(keyedBy: NestedKeys.self)

                self.first = try nestedContainer.decode(String.self, forKey: .first)
                self.last  = try nestedContainer.decode(String.self, forKey: .last)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedContainer(keyedBy: NestedKeys.self)

                try nestedContainer.encode(self.first, forKey: .first)
                try nestedContainer.encode(self.last,  forKey: .last)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(first: "First", last: "Last")) { (result) in
            XCTAssertEqual(result.first, "First")
            XCTAssertEqual(result.last,  "Last")
        }
    }

    ///
    /// Test the ability to encode/decode a value calling unkeyedContainer  multiple times.
    ///
    func testEncodeCallingMultipleUnkeyedContainers() {

        struct InputType: Codable {
            var value: String
            init(value: String) { self.value = value }

            init(from decoder: Decoder) throws {
                var _ = try decoder.unkeyedContainer()
                var container = try decoder.unkeyedContainer()

                self.value = try container.decode(String.self)
            }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer() /// throw the first away
                let _ = encoder.unkeyedContainer() /// And the second

                /// Use the third
                var container = encoder.unkeyedContainer()
                try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: "Test Value")) { (result) in
            XCTAssertEqual(result.value, "Test Value")
        }
    }

    ///
    /// Test that the UnkeyedContainer's `count` implementation returns the correct value.
    ///
    func testEncodeDecodeUnkeyedContainerCount() {

        struct InputType: Codable {
            var first: String
            var last:  String
            init(first: String, last: String) { self.first = first; self.last = last }

            enum CodingKeys: CodingKey { case name }
            enum NestedKeys: CodingKey { case first, last }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()

                self.first = try container.decode(String.self)
                self.last  = try container.decode(String.self)

                ///
                /// Note: Actual test for count is here
                ///
                XCTAssertEqual(container.count, 2)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()

                try container.encode(self.first)
                try container.encode(self.last)

                ///
                /// Note: Actual test for count is here
                ///
                XCTAssertEqual(container.count, 2)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(first: "First", last: "Last")) { (result) in
            XCTAssertEqual(result.first, "First")
            XCTAssertEqual(result.last,  "Last")
        }
    }

    ///
    /// Test the ability to encode/decode of a class/struct type using an `UnkeyedContainer`.
    ///
    func testEncodeDecodeOfStructClassType() {

        class InputValueType: Codable {
            let value: Int
            init(value: Int) { self.value = value }
            private enum CodingKeys: CodingKey { case value }

            required init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        class InputType: Codable {
            let value: InputValueType
            init(value: InputValueType) { self.value = value }
            private enum CodingKeys: CodingKey { case value }

            required init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(InputValueType.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        /// Run test on TestType
        _testCodableRoundTrip(input: InputType(value: InputValueType(value: 32))) { (result) in
            XCTAssertEqual(result.value.value, 32)
        }
    }

}
