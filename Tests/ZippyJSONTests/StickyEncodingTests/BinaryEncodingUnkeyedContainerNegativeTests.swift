///
///  BinaryEncodingUnkeyedContainerNegativeTests.swift
///
///  Copyright 2017 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 10/23/17.
///
import XCTest

///
/// Note: This file contains public interface tests so do not use @testable.
///
import ZippyJSON

/// =================================== NOTICE ========================================
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
/// Modify the  *.swift.gyb file instead.
/// ===================================================================================

///
/// Negative tests for unkeyed containers.
///
class BinaryEncodingUnkeyedContainerNegativeTests: XCTestCase {

    ///
	/// - throws: `DecodingError.typeMismatch` if the encountered encoded value is not convertible to the requested type.
    /// - throws: `DecodingError.valueNotFound` if the encountered encoded value is null, or of there are no more values to decode.
    ///

    // MARK: - `Bool` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Bool` value that is nil.
    ///
    func testDecodeBoolValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: Bool?
            init(value: Bool?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Bool.self, [], "Expected Bool value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Bool` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeBoolValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: Bool?
            init(value: Bool?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Bool.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Bool` value that was encoded as an `Int` type when using a UnkeyedContainer.
    ///
    func testDecodeBoolTypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Int
            init(value: Int) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: 64), expected: (ExpectedType.self, Bool.self, [], "Expected to decode Bool but found Int instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Bool` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeBoolTypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Int
            init(value: Int) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: 64), expected: (ExpectedType.self, Bool.self, [], "Expected to decode Bool but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Int` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int` value that is nil.
    ///
    func testDecodeIntValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: Int?
            init(value: Int?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: Int
            init(value: Int) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int.self, [], "Expected Int value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeIntValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: Int?
            init(value: Int?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: Int
            init(value: Int) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeIntTypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int
            init(value: Int) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int.self, [], "Expected to decode Int but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeIntTypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int
            init(value: Int) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int.self, [], "Expected to decode Int but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Int8` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int8` value that is nil.
    ///
    func testDecodeInt8ValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: Int8?
            init(value: Int8?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: Int8
            init(value: Int8) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int8.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int8.self, [], "Expected Int8 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int8` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeInt8ValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: Int8?
            init(value: Int8?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: Int8
            init(value: Int8) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int8.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int8.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int8` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeInt8TypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int8
            init(value: Int8) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int8.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int8.self, [], "Expected to decode Int8 but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Int16` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int16` value that is nil.
    ///
    func testDecodeInt16ValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: Int16?
            init(value: Int16?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int16.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int16.self, [], "Expected Int16 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int16` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeInt16ValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: Int16?
            init(value: Int16?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int16.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int16.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int16` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeInt16TypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int16.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int16.self, [], "Expected to decode Int16 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int16` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeInt16TypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int16.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int16.self, [], "Expected to decode Int16 but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Int32` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int32` value that is nil.
    ///
    func testDecodeInt32ValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: Int32?
            init(value: Int32?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int32.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int32.self, [], "Expected Int32 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int32` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeInt32ValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: Int32?
            init(value: Int32?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int32.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int32.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int32` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeInt32TypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int32.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int32.self, [], "Expected to decode Int32 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int32` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeInt32TypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int32.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int32.self, [], "Expected to decode Int32 but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Int64` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int64` value that is nil.
    ///
    func testDecodeInt64ValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: Int64?
            init(value: Int64?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int64.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int64.self, [], "Expected Int64 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Int64` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeInt64ValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: Int64?
            init(value: Int64?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Int64.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Int64.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int64` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeInt64TypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int64.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int64.self, [], "Expected to decode Int64 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int64` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeInt64TypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Int64.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Int64.self, [], "Expected to decode Int64 but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `UInt` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt` value that is nil.
    ///
    func testDecodeUIntValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: UInt?
            init(value: UInt?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt.self, [], "Expected UInt value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeUIntValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: UInt?
            init(value: UInt?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeUIntTypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt.self, [], "Expected to decode UInt but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeUIntTypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt.self, [], "Expected to decode UInt but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `UInt8` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt8` value that is nil.
    ///
    func testDecodeUInt8ValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: UInt8?
            init(value: UInt8?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt8.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt8.self, [], "Expected UInt8 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt8` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeUInt8ValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: UInt8?
            init(value: UInt8?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt8.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt8.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt8` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeUInt8TypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt8.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt8.self, [], "Expected to decode UInt8 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt8` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeUInt8TypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt8.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt8.self, [], "Expected to decode UInt8 but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `UInt16` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt16` value that is nil.
    ///
    func testDecodeUInt16ValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: UInt16?
            init(value: UInt16?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt16.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt16.self, [], "Expected UInt16 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt16` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeUInt16ValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: UInt16?
            init(value: UInt16?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt16.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt16.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt16` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeUInt16TypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt16.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt16.self, [], "Expected to decode UInt16 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt16` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeUInt16TypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt16.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt16.self, [], "Expected to decode UInt16 but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `UInt32` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt32` value that is nil.
    ///
    func testDecodeUInt32ValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: UInt32?
            init(value: UInt32?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt32.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt32.self, [], "Expected UInt32 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt32` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeUInt32ValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: UInt32?
            init(value: UInt32?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt32.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt32.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt32` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeUInt32TypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt32.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt32.self, [], "Expected to decode UInt32 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt32` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeUInt32TypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt32.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt32.self, [], "Expected to decode UInt32 but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `UInt64` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt64` value that is nil.
    ///
    func testDecodeUInt64ValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: UInt64?
            init(value: UInt64?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt64.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt64.self, [], "Expected UInt64 value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `UInt64` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeUInt64ValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: UInt64?
            init(value: UInt64?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(UInt64.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, UInt64.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt64` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeUInt64TypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt64.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt64.self, [], "Expected to decode UInt64 but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt64` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeUInt64TypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(UInt64.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, UInt64.self, [], "Expected to decode UInt64 but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Float` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Float` value that is nil.
    ///
    func testDecodeFloatValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: Float?
            init(value: Float?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: Float
            init(value: Float) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Float.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Float.self, [], "Expected Float value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Float` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeFloatValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: Float?
            init(value: Float?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: Float
            init(value: Float) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Float.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Float.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Float` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeFloatTypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Float
            init(value: Float) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Float.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Float.self, [], "Expected to decode Float but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Float` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeFloatTypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Float
            init(value: Float) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Float.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Float.self, [], "Expected to decode Float but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `Double` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Double` value that is nil.
    ///
    func testDecodeDoubleValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: Double?
            init(value: Double?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: Double
            init(value: Double) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Double.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Double.self, [], "Expected Double value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Double` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeDoubleValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: Double?
            init(value: Double?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: Double
            init(value: Double) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(Double.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, Double.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Double` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeDoubleTypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Double
            init(value: Double) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Double.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Double.self, [], "Expected to decode Double but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Double` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeDoubleTypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: Double
            init(value: Double) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Double.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, Double.self, [], "Expected to decode Double but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `String` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `String` value that is nil.
    ///
    func testDecodeStringValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: String?
            init(value: String?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: String
            init(value: String) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(String.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, String.self, [], "Expected String value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `String` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeStringValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: String?
            init(value: String?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: String
            init(value: String) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(String.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, String.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `String` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeStringTypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: String
            init(value: String) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(String.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, String.self, [], "Expected to decode String but found Bool instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `String` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeStringTypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: String
            init(value: String) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(String.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, String.self, [], "Expected to decode String but found UnkeyedDecodingContainer instead."))
    }

    // MARK: - `CodableType` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `CodableType` value that is nil.
    ///
    func testDecodeCodableTypeValueNotFoundWhenValueIsNil() {

        struct InputType: Codable {
            var value: CodableType?
            init(value: CodableType?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                try container.encodeNil()
            }
        }

        struct ExpectedType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(CodableType.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, CodableType.self, [], "Expected CodableType value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `CodableType` value that is nil, or when there are no more values to decode.
    ///
    func testDecodeCodableTypeValueNotFoundWhenNoMoreValues() {

        struct InputType: Codable {
            var value: CodableType?
            init(value: CodableType?) { self.value = value }

            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws { self.value = nil }

            func encode(to encoder: Encoder) throws {
                let _ = encoder.unkeyedContainer()
                /// Don't encode anything so we are at end  of container.
            }
        }

        struct ExpectedType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }
            enum CodingKeys: CodingKey { case value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer()
                self.value = try container.decode(CodableType.self)
            }
            func encode(to encoder: Encoder) throws {}
        }
        _testDecodeValueNotFound(input: InputType(value: nil), expected: (ExpectedType.self, CodableType.self, [], "Unkeyed container is at end."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `CodableType` value that was encoded as an `Bool` type when using a UnkeyedContainer.
    ///
    func testDecodeCodableTypeTypeMismatchWhenValueNotConvertable() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(CodableType.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, KeyedDecodingContainer<CodableType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found SingleValueDecodingContainer instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `CodableType` value that was not a correct container type when using a `UnkeyedContainer`.
    ///
    func testDecodeCodableTypeTypeMismatchWhenValueNotCorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(Bool.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer()
                var nestedContainer = container.nestedUnkeyedContainer()
                try nestedContainer.encode(self.value)
            }
        }

        struct ExpectedType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }

            init(from decoder: Decoder) throws {
                var container = try decoder.unkeyedContainer(); self.value = try container.decode(CodableType.self)
            }
            func encode(to encoder: Encoder) throws {
                var container = encoder.unkeyedContainer(); try container.encode(self.value)
            }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (ExpectedType.self, KeyedDecodingContainer<CodableType.CodingKeys>.self, [], "Expected to decode KeyedDecodingContainer<CodingKeys> but found UnkeyedDecodingContainer instead."))
    }
}
