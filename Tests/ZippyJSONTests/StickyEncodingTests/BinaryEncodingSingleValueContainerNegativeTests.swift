///
///  BinaryEncodingSingleValueContainerNegativeTests.swift
///
///  Copyright 2017 Tony Stone
///
///  Licensed under the Apache License, Version 2.0 (the "License");
///  you may not use this file except in compliance with the License.
///  You may obtain a copy of the License at
///
///  http://www.apache.org/licenses/LICENSE-2.0
///
///  Unless required by applicable law or agreed to in writing, software
///  distributed under the License is distributed on an "AS IS" BASIS,
///  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
///  See the License for the specific language governing permissions and
///  limitations under the License.
///
///  Created by Tony Stone on 10/23/17.
///
import XCTest

///
/// Note: This file contains public interface tests so do not use @testable.
///
import ZippyJSON

/// =================================== NOTICE ========================================
/// Do NOT edit this file directly as it will be regenerated automatically when needed.
///
/// Modify the  *.swift.gyb file instead.
/// ===================================================================================

///
/// Negative tests for  single value containers.
///
class BinaryEncodingSingleValueContainerNegativeTests: XCTestCase {

    // MARK: - `Bool` Tests

    ///
    /// Test that a `DecodingError.valueNotFound` is thrown when a user tries to decode a `Bool` value that was not prevously encoded at the root-level.
    ///
    func testDecodeValueNotFoundOfBool() {
        _testDecodeValueNotFound(input: [Optional<Int>.none], expected: ([Bool].self, [Bool].self, [], "Expected Bool value but found null instead."))
    }

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Bool` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfBoolWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Bool
            init(value: Bool) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: true), expected: (Bool.self, Bool.self, [], "Expected to decode Bool but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Int` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfIntWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int
            init(value: Int) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (Int.self, Int.self, [], "Expected to decode Int but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Int8` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int8` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfInt8WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int8
            init(value: Int8) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (Int8.self, Int8.self, [], "Expected to decode Int8 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Int16` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int16` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfInt16WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int16
            init(value: Int16) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (Int16.self, Int16.self, [], "Expected to decode Int16 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Int32` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int32` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfInt32WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int32
            init(value: Int32) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (Int32.self, Int32.self, [], "Expected to decode Int32 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Int64` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Int64` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfInt64WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Int64
            init(value: Int64) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (Int64.self, Int64.self, [], "Expected to decode Int64 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `UInt` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfUIntWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt
            init(value: UInt) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (UInt.self, UInt.self, [], "Expected to decode UInt but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `UInt8` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt8` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfUInt8WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt8
            init(value: UInt8) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (UInt8.self, UInt8.self, [], "Expected to decode UInt8 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `UInt16` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt16` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfUInt16WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt16
            init(value: UInt16) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (UInt16.self, UInt16.self, [], "Expected to decode UInt16 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `UInt32` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt32` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfUInt32WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt32
            init(value: UInt32) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (UInt32.self, UInt32.self, [], "Expected to decode UInt32 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `UInt64` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `UInt64` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfUInt64WhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: UInt64
            init(value: UInt64) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32), expected: (UInt64.self, UInt64.self, [], "Expected to decode UInt64 but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Float` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Float` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfFloatWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Float
            init(value: Float) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32.0), expected: (Float.self, Float.self, [], "Expected to decode Float but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `Double` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `Double` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfDoubleWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: Double
            init(value: Double) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: 32.0), expected: (Double.self, Double.self, [], "Expected to decode Double but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `String` Tests

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `String` value at the root-level and finds a container other than a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfStringWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: String
            init(value: String) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: "Test String"), expected: (String.self, String.self, [], "Expected to decode String but found KeyedDecodingContainer<CodingKeys> instead."))
    }

    // MARK: - `CodableType` Tests

    ///
    /// Note: Currently codable types using a SingleValueDecodingContainer have different error messages and type that single values because of the nature of the encoding.
    ///

    ///
    /// Test that a `DecodingError.typeMismatch` is thrown when a user tries to decode a `CodableType` value at the root-level and finds a container other that a SingleValueDecodingContainer.
    ///
    func testDecodeTypeMismatchOfCodableTypeWhenIncorrectContainerType() {

        struct InputType: Codable {
            var value: CodableType
            init(value: CodableType) { self.value = value }
        }
        _testDecodeTypeMismatch(input: InputType(value: CodableType(32)), expected: (CodableType.self, Int.self, [CodableType.CodingKeys.value], "Expected to decode Int but found KeyedDecodingContainer<CodingKeys> instead."))
    }
}
